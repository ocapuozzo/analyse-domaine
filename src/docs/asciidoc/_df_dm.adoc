= Notions de DF et DMR
ifndef::backend-pdf[]
:imagesdir: images
endif::[]

== Introduction

En phase d'analyse, la collecte des données et leurs relations est au centre des préoccupations.


image:analyse-artefacts.png[title="artefacts et analyse"]

Après avoir indentifier des concepts métier clés, ces derniers seront **regroupés** (en référence au concept d'_encapsulation_ et de _classe_) et placés
en relation de dépendances (_association_, _heritage_).

Notion de **D**épendance **F**onctionnelle (*DF*) et **D**épendance **M**ultivaluée (*DM*)


== Dépendance Fonctionnelle

soit A et B, deux données (concept métier) du système.

====

*Def* : Lorsqu'une valeur de A (une donnée) permet, au plus, de connaître une et une seule valeur de B,
on dit que *B dépend fonctionnellement de A*.

[cols="1,1,2", options="header"]
|===
|Concept
|Représentation
|Exemple

|Dépendance Fonctionnelle
| `A --- > B`

A est la *source* et B la *destination* (ou but)

|`idClient --- > nomClient`

La connaissance de l'id d'un client me permet de connaître son nom.
|===

====


=== Caractère d'unicité

Les *sources* des dépendances sont, par nature, des *identifiants*,
leur *valeur est unique* au sein du système.

NOTE: Par exemple, `idClient -> nomClient`,  `idClient` est la *clé* qui permet l'accès à l'information `nomClient`. Pour la cohérence du sytème,
cette clé doit être unique (absence de doublons)

TIP: La source d'une dépendance engendrera, dans la majorité des cas, une *entité* dénotant un concept métier. (voir plus bas : link:#règles-de-passage-du-gd-au-modèle-du-domaine-uml[règles-de-passage-du-gd-au-modèle-du-domaine-uml])

=== Propriétés des DF : Axiomes d'Armstrong

Les axiomes d'Armstrong (du nom de **_William Ward Armstrong_**, informaticien et mathématicien Canadien qui a défini les axiomes du système relationnel en 1974)
[cols="1,2,2", options="header"]
|===
|Propriété
|Définition
|Remarque

|*Réflexivité*
|A  →  A  (A propriété quelconque)
|Tautologie

|*Augmentation*
|si A  → B alors  A,C  → B &nbsp;  ∀C
|La source peut être augmentée sans nuire à la DF initiale. Une *erreur d'analyse* courante.

|*Transitivité*
|si A → B et B → C alors A → C
|Principe de base du marchandage de données personnelles !
|===

Dont on peut déduire les propriétés suivantes :

[cols="1,2,2", options="header"]
|===
|Propriété
|Définition
|Exemple

|*Pseudo-transitivité*
|si A  →  B et B,C  → D alors  A,C → D
|Les voleurs de données s'y intéressent fortement... (_social engineering attacks_)

|*Union*
|si A  →  B et A → C alors A → B,C
|(ne concerne bien évidemment que les cibles d'une même source)

Permet d'appliquer l'*encapsulation*

|*Décomposition*
|si A → B,C alors A → B et A → C
|L'inverse de l'union

|===


=== Qualités remarquables des DF

En phase d'analyse, on _ne retient que_ les DF ayant les qualités *_élémentaire_* et *_directe_*.

Intéressons-nous à ces qualités.


==== Qualité élémentaire

=====

*Def* :	Une DF est *élémentaire* si sa source est minimale (non en augmentation)

La DF : `A → B` est élémentaire s'il n'existe pas un ensemble de propriétés C,
tel que C est sous-ensemble de A, C différent de A, et `C → B`.

Contre-Exemple : Il aurait été faux de conserver la DF :

`(id_commande, id_fournisseur)  --- > date_commande`

si la DF  `id_commande  --- > date_commande` suffit.
=====

==== Qualité directe

=====

*Def* :	Une DF est *directe* si elle n'est pas transitive.

Contre exemple (DF transitive)

```
    transitivité
  A  ---------->  C  si une conséquence des DF :  A → B  et  B → C
```

Exemple : `idCmd --- > idFournisseur, nomFournisseur`,
qui se lit : "_la connaisance du numéro de commande me permet de connaître l'identifiant du fourniseur et son nom_" (ce qui est logique, vous en conviendrez)

Seulement voilà, la relation `idCmd --- > nomFournisseur` est une DF obtenue par transitivité s’il existe la DF (et c’est fort probable) : `idFournisseur --- > nomFournisseur`

Dans ce cas il faut transformer la DF transitive en deux DF directes :

`idCmd → idFournisseur` et `idFournisseur → nomFournisseur`

=====

== Dépendance Multivaluée

Il a des cas où la connaissance d'une propriété nous permet de connaître *plus d'une* autres propriétés du sytème.

Les axiomes d'Armstrong sont considérées agir sur les DM.

====

*Def* : Lorsqu'une valeur de A permet de connaître plus d'une valeur de B,
on dit que B est en *dépendance multivaluée* avec A, et on le note :
A ->-> B


[cols="1,1,2", options="header"]
|===
|Concept
|Représentation
|Exemple

|Dépendance Multivaluée
| A ->-> B

  ou

 A -\->>B

|idClient ->-> idCommande

La connaissance de l'id d'un client me permet de connaître l'ensemble de ses identifiants de commande.
|===


====

=== Qualités de DM

En phase d'analyse, nous ne retiendrons que les DM élémentaire, directe et réciproque.


==== Qualité élémentaire

======

*Def* : Une DM est *élémentaire* si la source est minimum.

======

==== Qualité directe

======

*Def* : Une DM est *directe* si aucune décomposition ne peut être appliquée (absence de transitivité)

======


==== Réciproques
======

*Def* : Lorsque A -\->> B [.underline]#et# B -\->> A, on dit que A et B sont en *DM Réciproques* (DMR).

[cols="1,1,2", options="header"]
|===
|Concept
|Représentation
|Exemple

|Dépendances Multivaluées Réciproques (DMR)
| A ->->o<-<-B

ou

A-\->>o<\<--B

|idPays ->->o<-<- idLangueParlee

* La connaissance de l'id d'un pays me permet de connaître l'ensemble des langues parlées dans ce pays

* La connaissance de l'id d'une langue parlée me permet de connaître l'ensemble des pays où la langue est parlée
|===

======

==== Caractère d'unicité

Tout comme les DF, la valeur de source d'une DMR doit être *unique* dans le sytème.

NOTE: Les systèmes de gestion de base de données relationnelles offrent plusieurs moyens de
déclarer une contrainte d'unicité (`PRIMARY KEY`, `CANDIDATE KEY`, `UNIQUE`, ...)


== Conduite de l'analyse

Ce chapitre introduit 2 principes à suivre lorsqu'on analyse des données en vue de modéliser le domaine métier.

Les deux règles sont des outils précieux en vue d'établir une base de données *cohérentes* et *sans doublons*.

IMPORTANT: Ne sont considérées ici que les dépendances *directes* et *élémentaires*,
ainsi que les dépendances multivaluées *réciproques*.

Présentation des deux principes.

====
*Principe 1 -  DF First*

Lorsque, dans un contexte donné, A et B sont en relation de type A -> B et B ->-> A,
seule la DF  (A -> B) sera retenue. (prévisage d'une relation type many-to-one).

====

====
*Principe 2 - DF Source Multi-Attributs == DMR*

Toute source multi-attributs d'une DF (DF à partie gauche composée, par exemple (A,B,C) -> D,E ) se doit d'être une
DMR élémentaire et directe et réciproque entre ses membres (prévisage d'une relation type many-to-many).

En appliquant la réflexivité, nous pouvons exprimer cette règle ainsi :

  (A, B) -> (A, B)   <=>   A -->>o<<-- B   <=>   (A,B)

NOTE: pour les source à n attributs, il faut vérifier les qualités directes et élémentaires.

  (A, B, C)  <=>   A -->>o<<-- B , A -->>o<<-- C, B -->>o<<-- C
  et vérifier l'absence d'une DF cachée comme : (B, C) -> A par exemple (en application du principe 1)

====

== Représentation graphiques des dépendances

Les dépendances, dans leur ensemble, peuvent graphiquement être représentées par

* un *Graphe de Dépendances (directes et élémentaires)* - orienté attribut/donnée

* un *Diagramme de classes UML (orienté entité)*, où ne figurent que les relations directes et
élémentaires. Dans ce contexte une classe est une Entité et les transitivités déduites sont
rarement signalées – UML les considère comme des attributs dérivés – avec une notation
spéciale

Soit les DF suivantes (contexte : agence de voyage) :
....
* numClient -> Pays  (pays de naissance)
* numClient -> Continent  (continent préféré)
* idPays -> libPays
* idPays -> idContinent
* idContinent -> libContinent
....

=== 1/ GD (graphe de dépendances)

Les dépendances sont réparties sur le plan, de façon à favoriser le plus possible leur compréhension.

Exemple de Graphe de Dépendances (focalisation sur les attributs)

image:gd-1.png[title="exemple graphe de dependances labelisés"]

=== 2/ Diagramme de classes UML

Exemple de Diagramme de Classes des Entités du Domaine (focalisation sur les classes - réalisé avec http://dia-installer.de/[dia])

image:GDF-UML.png[title="exemple diag. de classes du domaine"]

NOTE: le stéréotype \<<ID>> n'est pas obligatoire, ni \<<entity>> ,
si l'auteur du diagramme spécifie clairement qu'il s'agit de modèle conceptuel du domaine.


=== Normalisation GD/MCD

On prendra soin de ne conserver dans le graphe, et diagramme de classes, que les dépendances
*élémentaires* et *directes*, c-a-d non issues de transitivité. Un tel graphe est en *couverture minimale*.

Remarque: Un graphe dont toutes les dépendances transitives sont représentées est dit en *fermeture transitive*.

Ce mode de représentation (couverture minimale)

    • Evite les redondances (une propriété est notée une seule fois)
    • Les DF transitives sont facilement déduites (visible d'un premier coup d'œil)
    • Les rôles joués non triviaux sont textuellement notés



== Règles de passage du GD au Modèle du Domaine UML


====
*R1* : A une source d'un DF (à gauche de la flèche) correspond une *entité* qui admet un identifiant.

[cols="2,2", options="header"]
|===
|GD
|Modèle du domaine

|&nbsp;

&nbsp; &nbsp; A-\->B

| image:diag-gd-1.png[title="entite du domaine"]

|===

====


====
*R2* : Un but (une destination) commun à plusieurs DF (à droite de plusieurs flèches)
est considéré comme une source (voir R1)

[cols="2,2", options="header"]
|===
|GD
|Modèle du domaine

|`A -\-> C`  et `B -\-> C`

-------------------------------

image:gd-4.png[title="classe association"]&nbsp;
| image:diag-gd-4.png[title="2 associations"]

|===
====

====
*R3* : Une dépendance multivaluée réciproque (DMR) engendre une
*association many-to-many*.

[cols="2,2", options="header"]
|===
|GD
|Modèle du domaine

|`(A,B)` : A et B  sont en DMR
(une valeur de `A` permet d'atteindre plus d'une valeurs de `B`, et inversemement)

----------------------------

&nbsp; &nbsp; `A-\->>o<\<--B`

| image:diag-gd-2.png[title="association many to many"]

|===

====

====
*R4* : Une dépendance multivaluée réciproque (DMR) ciblant un attribut engendre une
*classe association* portant l'attribut.

[cols="2,2", options="header"]
|===
|GD
|Modèle du domaine

|`(A,B) -\-> C`

La connaissance d'une valeur de `A` *et* de `B` permet d'atteindre *au plus* une valeur de `C`.

Dit autrement, la connaissance d'un couple de valeurs `(A,B)` permet de connaitre, au plus une valeur de `C`.

-------------------------------------

image:gd-3.png[title="classe association"]&nbsp;
| image:diag-gd-asso.png[title="classe association"]

|===

====

=== Exemple d'application GD -> MCD

[cols="2,2", options="header"]
|===
|GD
|Modèle du domaine

|
`(A,B) -\-> C`
`E -\-> C`
`C -\-> D`

----------------------------------------------
image:gd-exemple.png[title="gd exemple"]&nbsp;
| image:classe-association-1.png[title="2 associations"]

|===

=== Réification d'une classe \<<association>>

Dans l'exemple précédent, la classe association `AB` est reliée à une association *many-to-many*.

Il est possible également de représenter une classe association par une entité "ordinaire",
associée à une contrainte d'unicité vers les entités concernées par la relation many-to-many.

Le changement de statut qui consiste à passer d'une association many-to-many à une entité,
est une *réification* (en philosopie, action qui consiste à _transposer une abstraction en objet concret_)

image:classe-association-2-entite-id.png[title="2 association-entite"]

NOTE: Observez bien le changement de multiplicité. A noter aussi que c'est la note, liée à l'entité `AB`
qui spécifie la contrainte associée à cette entité qui aurait pu être également exprimée
sous la forme d'une simple *contrainte d'unicité*.

Vous trouverez un autre exemple dans le chapitre MCD vers SR (entité `Documentation`)

=== Héritage et DF/DM

à venir

=== Exemple de conduite d'analyse

Su la base d'une petite étude de cas improvisée avec le concours
d'étudiants en ligne : link:exemples/etude-de-cas-exemple-vote.pdf[etude-de-cas-exemple-vote.pdf] (link:exemples/etude-de-cas-exemple-vote.odt[source odt])

=== Exercices

==== Ex 1

D'après les DF suivantes, construisez un GD et MCD
----
	(a, b) -> c
	c -> d
	e -> c
----
==== Ex 2

D'après les DF suivantes, construisez un GD et MCD
----
	(a, b) -> c
	(c, e) -> d
	d -> f
	d -> g
	a -> h
----

==== Ex 3

Une communauté de commune disposant de nombreux matériels agricole et travaux publics, souhaite
pouvoir louer ce matériel à ses administrés. Après une rencontre avec le responsable technique,
votre collègue vous soumet son analyse sur la base d'un ensemble d'attributs en dépendances :

----
NumEmprunteur -> NomEmprunteur
NumEmprunteur -> AdrEmprunteur
NumEmprunteur -> TelEmprunteur
(NumEnprunteur, idMateriel) -> DateEmprunt
(NumEnprunteur, idMateriel) -> DateRetour
idMateriel -> idCategorie
idMateriel -> idMarque
idMateriel -> idCategoriePrix
idCategorie -> LibCategorie
idMateriel -> AnneeSortie
idCategoriePrix -> LibCategoriePrix
idMateriel -> PrixLocation
idMateriel -> idEtat
idMarque -> NomMarque
idCategoriePrix -> PrixLocation
idEtat -> LibEtat  # {'EXCELLENT', 'TRES  BON', 'BON', 'MOYEN', 'EN REPARATION', 'HS'}
----

* L'analyse de votre collègue a quelques défauts. Tachez de les détecter et de corriger son analyse.

TIP: indices : A/ L'historicité d'un emprunt peut ne pas être garanti.  B/ Présence d'une DF non directe !

* Établir le GD ainsi qu'un MCD correspondant.


==== Ex 4


Le service informatique de l'organisation X, organisée en départements, souhaite modéliser le fait
qu'un logiciel (id, nom, éditeur) a été installé sur un serveur (id, nom, os),
à une date donnée, pour un département de l'entreprise (id, nom, budget).

* Établir le GD ainsi qu'un MCD correspondant.

==== Ex 5

On a demandé à un analyste de modéliser le domaine métier d'un quicailler.
Dans ce but, il décide de rencontrer un vendeur la quincaillerie.

Dialogue dans une quincaillerie de détail :

Analyste : comment appelez-vous cette pièce ?::
Vendeur : c'est une vis à bois 25/4 dont la référence est VB25.4AI

A : quelles sont les autres informations que vous enregistrez ?::
V :  son prix de vente H.T. par dizaine, son métal, ici de l'acier inox, son stock présent en centaines,

A : avez-vous un seul fournisseur ?::
V : non, par exemple cette vis nous est proposée par Grosdétail à 0,12 € et 0,18 € chez BigSA.

A: comment sont classées vos marchandises ?::
V : nous avons plusieurs familles de quincaillerie, ainsi la VB25.4AI est de la famille des vis à bois, par contre FX12OP est une petite fixation classée dans les fixations de plafond.
A : pouvez-vous me montrer un exemplaire de commande ?::
V : tenez, voici la dernière.
A : merci, donc le 18 mars 2015 vous avez passé la commande numéro 001245 chez Duclou, 125 rue Emile Sayfulin 93000 Ouzbekistan sur seine pour  45 boites (de 100 pièces) de CL15.2TR (visse à placo) et 15 boites de FX12OP.::
&nbsp;

* Établir le GD ainsi qu'un MCD correspondant.

== Formes Normales

== Modèle de domaine vers SR
Ce chapitre présente les principaux cas d’implémentation d’une analyse métier représenté
par un diagramme de classes du domaine métier (UML), en particulier les associations *ManyToOne*,
*OneToOne*, *ManyToMany* et *ManyToMany porteuse de propriétés*.

L’héritage fait l’objet d’un autre document.

=== ManyToOne

La relation très courante où une instance détient une référence à, au plus, une autre instance (une DF).

image:diagUML-analyse-sr.png[title="ManyToOne"]

=== OneToOne

Pour déterminer où placer la DF, il faut se demander qui, des deux entités,
est susceptible d'être instanciée avant l'autre !

image:diagUML-analyse-sr-ManyToOne.png[title="OneToOne"]

=== ManyToMany

Une DMR !

image:diagUML-analyse-sr-ManyToMany.png[title="ManyToMany"]

=== ManyToMany porteuse (clé multi-attributs)

Une DMR porteuse d'information (implémentation d'école)

image:diagUML-analyse-sr-ManyToMany-Porteuse.png[title="ManyToMany"]

=== ManyToMany porteuse (réification)

Exemple de *réification* d'association (généralement pour faire émerger un *concept métier*)

TIP: On remarquera l'absence de clé primaire composée, remplacée par une clé technique mono-attribut et clé candidate multi-attributs.

image:diagUML-analyse-sr-ManyToMany-Porteuse-v2.png[title="ManyToMany"]

== Exercices
